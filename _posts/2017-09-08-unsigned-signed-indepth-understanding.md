---
layout:     post
title:      使用Python的struct模块组包的一个问题
keywords:   博客
categories: [自动化测试]
tags:	    [unsigned, 无符号类型]
---

在上一篇博客中，提到可以使用Python的struct模块来处理字节流，以完成组包和解包的功能。在将Python版本由2.6版本升级到2.7版本后，原来可以跑通的脚本报错了，错误信息大概是这个样子：error: integer out of range for 'I' format code，'I'是struct.pack_into(fmt, buffer, offset, v1, v2, ...)的参数，解决方法很简单，用'i'替换'I'再次运行脚本就不会报错了。下面我们来探寻一下深层的原因。


# Python的struct模块

遇到这个问题第一个反应是去查看Python的struct模块[官方文档](https://docs.python.org/2/library/struct.html)，format character中的'I'在Python里对应integer数据类型，在C里对应unsigned int数据类型，4个字节长度，而'i'在Python里也是对应integer数据类型，在C里则对应int数据类型，同样也是4个字节长度。唯一的区别：一个是unsigned int，一个是int，区别是什么呢？


# C语言的unsigned int和int

### 有符号和无符号的区别

unsigned即无符号，signed即有符号。比如5没有符号，-5有符号。有无符号的根本原因是因为数据出现了溢出。我们知道数据在计算机中以二进制存储，并且占据一定的空间，而这个空间属于计算机分配的空间。以无符号的32位int类型为例，其最大值是4294967295，超过了4294967295就叫溢出。有符号的32位int类型的范围是-2147483648~2147483647，对于有符号整型来说，它的二进制最高位称为符号位，而不是数据位。然而在计算机中，负数是不存在的，它是以二进制补码的形式表示和存放的。

### 原码，反码和补码

在了解为什么计算机要使用补码之前，有必要先了解原码，反码和补码的概念（计算机专业的必修课内容）。

* 原码：符号位加上真值的绝对值, 即用第一位表示符号, 其余位表示值
>原码不能直接参加运算，可能会出错。例如数学上，1+(-1)=0，而在二进制中00000001+10000001=10000010，换算成十进制为-2。所以原码的符号位不能直接参与运算，必须和其它位分开，这就增加了硬件的开销和复杂性。

* 反码的表示方法是：正数的反码是其本身；负数的反码是在其原码的基础上, 符号位不变，其余各个位取反。

* 补码的表示方法是：正数的补码是其本身；负数的补码是在其原码的基础上, 符号位不变, 其余各位取反, 最后+1。(即在反码的基础上+1)

### 为何会有反码和补码

对于计算机要设计的尽量简单，而区分符号位会让计算机的基础电路设计变得十分复杂。于是人们想出了将符号位也参与运算，并且只保留加法的方法。

* 为了解决原码做减法的问题, 出现了反码。发现用反码计算减法, 结果的真值部分是正确的。而唯一的问题其实就出现在"0"这个特殊的数值上. 虽然人们理解上+0和-0是一样的, 但是0带符号是没有任何意义的。而且会有[0000 0000]<sub>原</sub>和[1000 0000]<sub>原</sub>两个编码表示0。
>1-1 = 1 + (-1) = [0000 0001]<sub>原</sub> + [1000 0001]<sub>原</sub> = [0000 0001]<sub>反</sub> + [1111 1110]<sub>反</sub> = [1111 1111]<sub>反</sub> = [1000 0000]<sub>原</sub> = -0

* 补码的出现，解决了0的符号以及存在两个编码的问题，而且还能够多表示一个最低数。这就是为什么8位二进制，使用原码或反码表示的范围为[-127, +127]，而使用补码表示的范围为[-128, 127]。__在计算机中，负数是不存在的，是以二进制补码的形式表示和存放的。__
>1-1 = 1 + (-1) = [0000 0001]<sub>原</sub> + [1000 0001]<sub>原</sub> = [0000 0001]<sub>补</sub> + [1111 1111]<sub>补</sub> = [0000 0000]<sub>补</sub> = [0000 0000]<sub>原</sub>

# 深入

### 同余的概念

两个整数a，b，若它们除以整数m所得的余数相等，则称a，b对于模m同余。

### 负数取模
负数取模的方法是：x mod y等于 x 减去 y 乘上 x与y的商的下界。
以 -2 mod 12 为例：
> -2 - 12 x (-1) = 12 - 2 = 10
>
> -2 与 10 是同余的

>同理，-4 与 8 是同余的

### 同余数的线性运算定理

如果a ≡ b (mod m)，c ≡ d (mod m)，那么   
(1)  a ± c = b ± d (mod m)  
(2)  a * c = b * d (mod m)

-1的反码是1111 1110，去掉符号位是126，而-1 ≡ 126 (mod 127)   
根据上述定理，2-1 ≡ 2+126 (mod 127)，符合预期2-1 = 1   
即一个数的反码，实际上是这个数对于一个模的同余数，这个模是所能表示的最大值  
而补码则是在反码的基础上加1，相当于增加了模的值-1 ≡ 127 (mod 128)   
2-1 ≡ 2+127 (mod 128)

### 给无符号类型赋值负数的结果

32位编译器下unsigned类型占4个字节，最大值是2的32次方，即4294967296
假设u1,u2都是unsigned类型 u1 = 10，u2 = 42，那么u1 - u2 = 4294967264  
因为-32和4294967264是4294967296的同余数。

回到文章开始的那个问题，报错的原因是给一个unsigned类型赋值了一个负数。在Python2.7之前的版本，这种情况报warning，但不影响程序执行，在Python2.7版本则报error。

# 结论

* 如果赋值给无符号类型一个超过它表示范围的值（如负数），结果是初始值对无符号类型表示数值最大值取模后的余数。
* 如果表达式中同时有无符号类型和有符号类型，会默认将有符号类型转换为无符号类型进行运算，运算结果也是无符号类型。
* 避免混用无符号类型和有符号类型！
* 慎用无符号类型！