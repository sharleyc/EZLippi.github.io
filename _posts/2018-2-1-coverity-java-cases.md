---
layout:     post
title:      常见的Coverity缺陷类型（for Java）
keywords:   博客
categories: [杂项]
tags:	    [Coverity,Java]
---
和其它代码静态检测工具相比，Coverity的特别之处在于查找精确，具有业界最低的误报率（小于15%）。使用Coverity更易于发现像NULL指针引用、内存泄漏和缓冲区溢出等常常会带来很严重的质量和安全风险的缺陷类型，如果使用传统的测试方法，有时是难以找到的。公司内部Coverity相关的文章，最早可以追溯到12年，而使用Coverity提升过程质量的案例不胜枚举。笔者所在的部门是在17年才正式引入Coverity，半年多的时间，得到了开发人员的认可，整体bug修复率达到90%以上，而新增bug修复率则达到了100%。本文列举了一些Coverity能发现的常见的缺陷类型（For Java）。   
   
## 空值检查
1、Dereference after null check   
含义：检查引用空变量的情况。程序在前面步骤已判定为空变量，继续引用该变量。

2、Dereference before null check   
含义：检查引用空变量的情况。引用了变量后，才对变量进行是否为空的判断，如果变量前面为空，就会导致程序抛出异常。

3、Dereference null argument   
含义：检查方法中传入空变量的情况。如果把可能为Null的变量直接传入方法作为参数，如果value为Null，那么会抛出NullPointerException。

4、Dereference null return value   
含义：空返回检查。很多情况下，程序员没有对程序的返回值进行判定，并且将返回值用到了另外一段代码中，这种做法可能会导致应用Crash。

5、Explicit null dereference   
含义：空返回检查。很多情况下，程序员没有对程序的返回值进行判定，并且将返回值用到了另外一段代码中，这种做法可能会导致应用Crash。

   
     
## 复制黏贴错误
1、Copy-paste error  
含义：在实际的代码开发中，有很多复制粘贴的代码，Coverity会检查这类复制粘贴的错误，按照一个错误的匹配模式，提示用户某处复制代码后，参数没有做相应的更改。

  
## 父类调用
1、Missing call to superclass  
含义：如果一个方法被重写多次，在一个代码片段中，重写该方法调用父类的比例达到了某个比例（65%），那么其他没有调用父类的方法就被判定为缺陷。原因可能是因为程序员忘记给该方法包含父类调用。这种情况能够导致难以诊断的错误和其他意外的行为。
备注: 该类型有一定的误报率，有些用继承的，父子类完全不一样的实现，但是又没用抽象方法实现。


## 死锁
1、Thread deadlock   
含义：这个方法检查线程占用双锁的情况。线程1独占(锁定)资源A，等待获得资源B后，才能继续执行；同时线程2独占（独占）资源B，等待获得资源A后，才能继续执行；这种情况会导致死锁而使程序挂起。导致死锁有以下几个条件：  
a. 循环等待；  
b. 不可剥夺；  
c. 资源独占；  
d. 保持申请；  
为防止死锁，程序设计中应尽量避免嵌套封锁。


## 冗余代码
1、Structurally dead code  
含义：该方法检查很多的实例代码实际上没有运行，原因为该分支的条件永远没法满足或该分支的条件一直不变，致使某些代码没有执行。错误的代码假设和其他的一些逻辑错误是导致死代码的一部分原因。这类缺陷将会导致非常广泛的影响。常规理解是增加了代码量（或者配置文件内容），更深层次的错误，是逻辑错误导致了很多重要代码没有执行，从而程序没有按照预期的结果运行。


## 并行访问
1、Unguarded read  
含义：检查参数的读取没有锁的情况，可能有些线程读取，有些更新，将会导致读取到的数据是预期之外的，会导致系统异常或不可预知的错误。
备注: 锁应用在多线程环境下比较普遍，为了保证在读数据的时候数据不被其他线程修改，必须加锁。

2、Unguarded write   
含义：检查参数的更新没有锁的情况，很多参数应用的实例在更新过程中不加锁，会导致多个线程同时更新参数的情况。这类问题会导致系统的异常行为和不可预知的错误。


## 控制流
1、Missing break in switch   
含义：检查在switch使用过程中，缺少break声明的情况。case语句或者default申明的代码片段中，如果缺少break，会导致程序的多个路径同时被执行（case语句一般只执行一个路径）。

#补充
使用Coverity能提高版本质量，如何分析质量升高的效果呢？一种方法是根据已定级事故/现网缺陷的分析，事故原因一般可分为代码问题、漏测、运维操作、配置问题、流程问题、设计问题、服务器问题等，应用Coverity之后应该能看到因为代码问题导致的事故比例在下降。
