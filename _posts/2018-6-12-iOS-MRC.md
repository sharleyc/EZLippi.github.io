---
layout:     post
title:      iOS学习之MRC    
keywords:   博客
categories: [iOS]
tags:	    [MRC，内存管理]
---

有效的内存管理，通常认为包含两方面内容： 

1、内存分配：程序创建对象时需要为对象分配内存。合理的设计是，尽量减少对象的创建，并减少创建过程中的内存开销。   
2、内存回收：当程序不再需要对象时，系统必须及时回收这些对象所占用的内存，以便程序可以再次使用这些内存。  
 
内存回收相比内存分配，操作更加复杂，管理更加困难。典型的内存回收策略有两种：自动回收和混合回收。Xcode4.2（iOS 5）引入了ARC(Automatic Reference Counting)，ARC机制会自动释放对象所占的内存，如果只是开发Mac应用程序，甚至可以使用自动垃圾回收机制。遗憾的是iOS应用开发，无法使用自动垃圾回收机制。如果要兼容更早iOS平台的应用，就要使用MRC(Manual Reference Counting)了。    


## 对象的引用计数           

系统怎么知道何时需要回收对象呢？
   
OC采用了一种被称为引用计数(Reference Counting)的机制来跟踪对象的状态。每个对象都有一个与之关联的整数，这个整数被称为引用计数。  

当程序调用方法名alloc,new,copy,mutabaleCopy开头的方法来创建对象时，该对象的引用计数加1；  
程序调用对象的retain方法时，该对象的引用计数加1；     
程序调用对象的release方法时，该对象的引用计数减1；    

当一个对象的引用计数为0时，表明程序不再需要该对象了，系统会自动调用该对象的dealloc方法来销毁它。
    

## 对象的所有权  

手动内存释放的基本思路应该遵循：谁把对象的引用计数加1，谁就要负责在“临死”前把该对象的引用计数减1，即任何实体（对象、函数）在结束前都应该把其它对象的引用计数恢复到开始前的状态。但是，有些函数需要返回一个对象，就不能立即将该对象的引用计数减1，否则该对象可能在返回前被销毁。为了延迟销毁，可以使用自动释放池。  


## 使用自动释放池     

自动释放池的原理十分简单，当把对象添加到自动释放池中时，实际上是把对象添加到NSMutalbeArray集合中，接着程序需要重写NSMutalbeArray集合的release方法，并在该方法中依次调用容器中每个对象的release方法。   

自动释放池也是一个OC对象，同样遵守相同的对象回收机制。只要自动释放池的引用计数为0，系统就会自动销毁自动释放池对象。程序把对象添加到自动释放池中，接下来程序只要控制释放自动释放池即可，自动释放池会负责把容器中所有对象的引用计数减1。    

## 手动内存管理的规则总结  

1、调用对象的release方法并不是销毁该对象，只是将该对象的引用计数减1；当一个对象的引用计数为0时，系统会自动调用该对象的dealloc方法来销毁该对象。   
2、当自动释放池被回收时，自动释放池会依次调用池中每个对象的release方法。如果该对象调用release方法后引用计数变为0，那么该对象将要被销毁；否则该对象可以从自动释放池中“活”下来。  
3、当程序使用以alloc,new,copy,mutabaleCopy开头的方法来创建对象时，该对象的引用计数为1，当不再使用该对象时，需要调用该对象的release方法或者autorelease方法。   
4、如果使用retain方法为对象增加过引用计数，则用完该对象后需要调用release方法来减少该对象的引用计数，并保证retain次数与release次数相等。    
5、如果通过其他方法获取了对象，且对象是一个临时对象，若在自动释放池上下文中使用该对象，那么使用完成后无须理会该对象的回收，系统会自动回收该对象。如果程序需要保留这个临时对象，则需要手动调用retain来增加该临时对象的引用计数；或者将该临时对象赋值给retain,strong或copy指示符修饰的属性。   
6、在Cocoa或iOS的事件循环中，在每个事件处理方法执行之前都会创建自动释放池，方法执行完成后会回收自动释放池。如果希望自动释放池被回收后，池中某些对象能“活”下来，程序必须增加该对象的引用计数，保证该对象的引用计数大于它调用autorelease的次数。    

## 内存泄漏检测工具  

手Q（iOS）由于历史原因，没有使用ARC，采用MRC非常容易引起内存泄漏。而使用Instrument自带的leak工具会使APP异常卡顿影响测试。因此开发了QQLeak这款工具。  

### QQLeak原理  

目前QQLeak支持所有OC对象及C标准库malloc区域的泄漏检测，检测内存泄漏的原理是基于内存对象的“无引用”分析，即分析出在内存中驻留的无任何指针引用的内存对象。QQLeak内存泄漏检测主要分为两个阶段：内存对象记录阶段和内存指针扫描阶段。   

内存对象记录阶段  

通过hook iOS内存分配的关键方法，将所有内存对象分配的虚拟内存地址和堆栈记录到哈希表中，因为内存分配是比较底层的方法，当记录对象较多时，可能会对性能有一定的影响，在手Q中实测大概会增加5%左右的耗时。但基本不影响正常的功能测试。   

内存指针扫描阶段  

这是内存泄漏检测最关键的步骤，通过扫描ios虚拟内存空间中所有可能包含“指针变量”的区域，我们可以分析出在整个内存空间中都没有指针指向的内存对象，这些对象即是我们要找的“内存泄漏”对象。     

  ![](/images/images_2018/6-12_1.png)    

### 由QQLeak检测出来的泄漏  

1、变量被retain后没有释放   

解决方法：在dealloc中对该对象进行release。  

注：将变量直接赋值nil的效果跟release的效果是一样的，因为self.xxx = nil会调用默认setter方法，默认setter方法会调用release，同时赋值为nil，这样更安全。      

2、由Block引起的循环引用  

如果两个对象相互引用，而内存中已经没有指向这两个对象的指针，则这两个对象会成为环状孤岛。这种情况也是可能被QQLeak检测到的。    

解决方法：在MRC中，使用\_block修饰self（其作用是允许在block中进行修改），或者在block执行完后，将block置nil，这样也可以打破循环引用；在ARC中，使用_weak修饰self，使其在block中不被持有，打破循环引用。        


 
